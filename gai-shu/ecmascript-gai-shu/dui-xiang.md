# 对象

Even though ECMAScript includes syntax for class definitions, ECMAScript objects are not fundamentally class-based such as those in C++, Smalltalk, or Java. Instead objects may be created in various ways including via a literal notation or via_constructors_which create objects and then execute code that initializes all or part of them by assigning initial values to their properties. Each constructor is a function that has a property named`"prototype"`that is used to implement_prototype-based inheritance_and_shared properties_. Objects are created by using constructors in**new**expressions; for example,`new Date(2009,11)`creates a new Date object. Invoking a constructor without using**new**has consequences that depend on the constructor. For example,`Date()`produces a string representation of the current date and time rather than an object.

Every object created by a constructor has an implicit reference \(called the object's_prototype_\) to the value of its constructor's`"prototype"`property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the_prototype chain_. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.![](/assets/FireShot Capture 2 -  - http___www.ecma-international.org_ecma-262_8.0_index.html#sec-ecmascript-.png)In a class-based object-oriented language, in general, state is carried by instances, methods are carried by classes, and inheritance is only of structure and behaviour. In ECMAScript, the state and methods are carried by objects, while structure, behaviour, and state are all inherited.

All objects that do not directly contain a particular property that their prototype contains share that property and its value. Figure 1 illustrates this:

**CF**is a constructor \(and also an object\). Five objects have been created by using`new`expressions:**cf1**,**cf2**,**cf3**,**cf4**, and**cf5**. Each of these objects contains properties named`q1`and`q2`. The dashed lines represent the implicit prototype relationship; so, for example,**cf3**'s prototype is**CFp**. The constructor,**CF**, has two properties itself, named`P1`and`P2`, which are not visible to**CFp**,**cf1**,**cf2**,**cf3**,**cf4**, or**cf5**. The property named`CFP1`in**CFp**is shared by**cf1**,**cf2**,**cf3**,**cf4**, and**cf5**\(but not by**CF**\), as are any properties found in**CFp**'s implicit prototype chain that are not named`q1`,`q2`, or`CFP1`. Notice that there is no implicit prototype link between**CF**and**CFp**.

Unlike most class-based object languages, properties can be added to objects dynamically by assigning values to them. That is, constructors are not required to name or assign values to all or any of the constructed object's properties. In the above diagram, one could add a new shared property for**cf1**,**cf2**,**cf3**,**cf4**, and**cf5**by assigning a new value to the property in**CFp**.

Although ECMAScript objects are not inherently class-based, it is often convenient to define class-like abstractions based upon a common pattern of constructor functions, prototype objects, and methods. The ECMAScript built-in objects themselves follow such a class-like pattern. Beginning with ECMAScript 2015, the ECMAScript language includes syntactic class definitions that permit programmers to concisely define objects that conform to the same class-like abstraction pattern used by the built-in objects.

